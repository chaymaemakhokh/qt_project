\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}

\title{Documentation du modèle et de l'architecture\\
\textbf{Système de Gestion d'Entrepôt (Warehouse Manager)}}
\author{Chaymae MAKHOKH \and Anas BZIOUI}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section*{Introduction}

Ce document décrit la structure du modèle, les principales classes métiers
et les éléments de l'architecture Qt du projet \emph{Warehouse Manager}.
L'objectif est de relier clairement :
\begin{itemize}
  \item le diagramme UML fourni,
  \item l'implémentation C++ dans le projet Qt (dossier \verb|domain| et contrôleurs),
  \item les fonctionnalités visibles dans l'interface utilisateur
        (dialogs d'ajout, hiérarchie dans la \texttt{QTreeView}, etc.).
\end{itemize}

Toutes les classes du modèle sont regroupées dans le dossier
\verb|src/domain| du projet Qt, et la logique applicative dans le dossier
\verb|controlleur|.

Les classes principales implémentées sont~:
\begin{itemize}
  \item \texttt{Product} (classe abstraite),
  \item \texttt{ProduitAvecCaracteristiques},
  \item \texttt{ProduitAvecCycleDeVie},
  \item \texttt{Conteneur},
  \item \texttt{Palette}, \texttt{ElementsPalette},
  \item \texttt{Entrepot},
  \item \texttt{ContrainteCompatibilite}, \texttt{ReglesCompatibilite},
  \item les énumérations \texttt{TypeProduit}, \texttt{TypeConteneur},
        \texttt{EtatProduit},
  \item les contrôleurs \texttt{ProduitControleur} et
        \texttt{ConteneurControleur},
  \item les vues Qt : \texttt{MainWindow}, \texttt{ajouterProduit},
        \texttt{ajouterconteneur}.
\end{itemize}

\section{Vue d'ensemble de l'architecture}

\subsection{Structure métier}

Le modèle représente la structure suivante~:

\begin{itemize}
  \item Un \textbf{Entrepôt} (\texttt{Entrepot}) contient plusieurs
        \textbf{Conteneurs} (\texttt{Conteneur}) et plusieurs
        \textbf{Palettes} (\texttt{Palette}).
  \item Chaque \textbf{Conteneur} contient une liste de \textbf{produits}
        (\texttt{Product*}), qui peuvent être de deux types concrets~:
        \texttt{ProduitAvecCaracteristiques} (non périssable) ou
        \texttt{ProduitAvecCycleDeVie} (périssable).
  \item Chaque \textbf{Palette} contient un ensemble d'\textbf{éléments}
        (\texttt{ElementsPalette}) qui référencent des produits avec des quantités.
  \item Les compatibilités entre types de produits sont exprimées via
        des \texttt{ContrainteCompatibilite}, regroupées dans
        \texttt{ReglesCompatibilite}.
\end{itemize}

\subsection{Structure logicielle}

L'application suit une architecture inspirée MVC~:

\begin{itemize}
  \item \textbf{Modèle} : classes du dossier \verb|domain|
        (\texttt{Product}, \texttt{Conteneur}, \texttt{Palette},
        \texttt{Entrepot}, etc.).
  \item \textbf{Contrôleurs} :
        \begin{itemize}
          \item \texttt{ProduitControleur} gère la liste des produits
                en mémoire et fournit des méthodes de création.
          \item \texttt{ConteneurControleur} gère la liste des conteneurs
                et permet d’y ajouter des produits.
        \end{itemize}
  \item \textbf{Vues Qt} :
        \begin{itemize}
          \item \texttt{MainWindow} : fenêtre principale avec
                \texttt{QTreeView} pour visualiser la hiérarchie
                conteneurs / produits.
          \item \texttt{ajouterProduit} : boîte de dialogue pour
                la création d’un produit.
          \item \texttt{ajouterconteneur} : boîte de dialogue pour
                la création d’un conteneur.
        \end{itemize}
\end{itemize}

Les contrôleurs servent de \og pont \fg{} entre les vues Qt
et le modèle métier.

\section{Énumérations}

Toutes les énumérations sont définies dans \texttt{enums.h} et
leurs fonctions utilitaires dans \texttt{enums.cpp}. Elles sont
déclarées comme métatypes Qt via \verb|Q_DECLARE_METATYPE| afin
de pouvoir être stockées dans des \texttt{QVariant} et utilisées
dans les \texttt{QComboBox} de l'interface.

\subsection{\texttt{TypeProduit}}

\paragraph{Rôle}
Enumération représentant le type d'un produit.

\paragraph{Valeurs}
\begin{itemize}
  \item \texttt{Alimentaire}
  \item \texttt{Electronique}
  \item \texttt{Medicament}
  \item \texttt{Autre} (valeur par défaut)
\end{itemize}

\paragraph{Utilisation}
\begin{itemize}
  \item Attribut \texttt{m\_type} dans \texttt{Product}.
  \item Attributs \texttt{m\_typeA} et \texttt{m\_typeB} dans
        \texttt{ContrainteCompatibilite}.
\end{itemize}

\subsection{\texttt{TypeConteneur}}

\paragraph{Rôle}
Enumération représentant le type d'un conteneur
(normal, froid, fragile, etc.).

\paragraph{Valeurs}
\begin{itemize}
  \item \texttt{Normal}
  \item \texttt{Froid}
  \item \texttt{Fragile}
  \item \texttt{Autre}
\end{itemize}

\paragraph{Utilisation}
Attribut \texttt{m\_type} dans la classe \texttt{Conteneur},
et dans l'interface pour alimenter la \texttt{QComboBox}
\texttt{TypeConteneur\_2}.

\subsection{\texttt{EtatProduit}}

\paragraph{Rôle}
Enumération représentant l'état d'un produit.

\paragraph{Valeurs}
\begin{itemize}
  \item \texttt{Stocke}
  \item \texttt{Expedie}
\end{itemize}

\paragraph{Utilisation}
Retour par les méthodes virtuelles \texttt{etat()} dans
\texttt{Product} et stocké dans les sous-classes concrètes.

\section{Modèle de produits}

\subsection{\texttt{Product} (classe abstraite)}

\paragraph{Rôle}
Classe de base abstraite représentant un produit de l'entrepôt.
Elle ne contient que l'identité commune, le type et la capacité
maximale. Les aspects physiques et les dates sont gérés dans les
sous-classes.

\paragraph{Attributs privés}
\begin{itemize}
  \item \texttt{QString m\_idProduit}
  \item \texttt{QString m\_nom}
  \item \texttt{TypeProduit m\_type}
  \item \texttt{double m\_capaciteMax}
\end{itemize}

\paragraph{Méthodes publiques}
\begin{itemize}
  \item Accesseurs : \texttt{idProduit()}, \texttt{setIdProduit()},
        \texttt{nom()}, \texttt{setNom()}, \texttt{type()},
        \texttt{setType()}, \texttt{capaciteMax()},
        \texttt{setCapaciteMax()}.
  \item Méthodes virtuelles pures (polymorphisme)~:
        \begin{itemize}
          \item \texttt{virtual double poids() const = 0;}
          \item \texttt{virtual double volume() const = 0;}
          \item \texttt{virtual QDate dateEntreeStock() const = 0;}
          \item \texttt{virtual QDate datePeremption() const = 0;}
          \item \texttt{virtual EtatProduit etat() const = 0;}
        \end{itemize}
  \item Méthode utilitaire :
        \texttt{bool estPerime(const QDate\& jour) const;}
        qui teste la validité de \texttt{datePeremption()}.
\end{itemize}

\paragraph{Signal}
\begin{itemize}
  \item \texttt{void productChanged();} émis à chaque modification.
\end{itemize}

Ce design permet de manipuler tous les produits via des
\texttt{Product*} (par exemple dans les conteneurs), tout en
déléguant le comportement concret aux sous-classes.

\subsection{\texttt{ProduitAvecCaracteristiques}}

\paragraph{Rôle}
Produit non périssable : poids, volume, conditions de conservation
et état. La date de péremption n'est pas utilisée.

\paragraph{Attributs spécifiques}
\begin{itemize}
  \item \texttt{double m\_poids}
  \item \texttt{double m\_volume}
  \item \texttt{QString m\_conditions}
  \item \texttt{QDate m\_dateEntreeStock}
  \item \texttt{EtatProduit m\_etat}
\end{itemize}

\paragraph{Redéfinitions}
\begin{itemize}
  \item \texttt{double poids() const override;}
  \item \texttt{double volume() const override;}
  \item \texttt{QDate dateEntreeStock() const override;}
  \item \texttt{QDate datePeremption() const override;} (renvoie une date
        invalide pour indiquer \og non périssable \fg).
  \item \texttt{EtatProduit etat() const override;}
\end{itemize}

\paragraph{Utilisation}
Ce type est choisi lorsque l'utilisateur coche
\og Produit avec des caractéristiques \fg{} dans la
boîte de dialogue \texttt{ajouterProduit}. Les champs
\texttt{Poids}, \texttt{Volume}, \texttt{ConditionsConservation},
\texttt{DateEntreeStock} sont alors utilisés, et le champ
\texttt{DatePeremption} est masqué.

\subsection{\texttt{ProduitAvecCycleDeVie}}

\paragraph{Rôle}
Produit périssable : possède un cycle de vie complet avec
dates d'entrée en stock et de péremption.

\paragraph{Attributs spécifiques}
\begin{itemize}
  \item \texttt{double m\_poids}
  \item \texttt{double m\_volume}
  \item \texttt{QDate m\_entree}
  \item \texttt{QDate m\_peremption}
  \item \texttt{EtatProduit m\_etat}
\end{itemize}

\paragraph{Redéfinitions}
Même principe que la classe précédente, mais ici
\texttt{datePeremption()} renvoie une date valide et permet
d'appliquer des stratégies FEFO (First Expire First Out).

\section{Conteneurs, palettes et entrepôt}

\subsection{\texttt{Conteneur}}

\paragraph{Rôle}
Représente un conteneur physique dans l'entrepôt.

\paragraph{Attributs}
\begin{itemize}
  \item \texttt{QString m\_idConteneur}
  \item \texttt{TypeConteneur m\_type}
  \item \texttt{double m\_capaciteMax}
  \item \texttt{QList<Product*> m\_produits}
\end{itemize}

\paragraph{Méthodes principales}
\begin{itemize}
  \item Accesseurs classiques sur l'identité et le type.
  \item \texttt{const QList<Product*>\& produits() const;}~: accès en lecture.
  \item \texttt{double poidsTotal() const;}~: somme des poids.
  \item \texttt{bool peutAjouter(Product *p) const;}~: vérifie si le poids
        total reste inférieur à \texttt{m\_capaciteMax}.
  \item \texttt{bool ajouterProduit(Product *p);}~: ajoute le produit ici
        si \texttt{peutAjouter()} est vrai.
  \item \texttt{void retirerProduit(Product *p);}~: retire toutes les occurrences.
\end{itemize}

\paragraph{Signaux}
\begin{itemize}
  \item \texttt{conteneurChanged()}, \texttt{produitAjoute(Product*)},
        \texttt{produitRetire(Product*)}.
\end{itemize}

\subsection{\texttt{ElementsPalette} et \texttt{Palette}}

Ces classes implémentent la logique de palettes d'expédition
(liste d'éléments avec quantités, vérification des règles de
compatibilité, etc.), en conformité avec le diagramme UML.
Elles ne sont pas détaillées ici car la fonctionnalité principale
développée actuellement concerne surtout la partie
\emph{conteneurs / produits} et la visualisation dans l'interface.

\subsection{\texttt{Entrepot}}

\paragraph{Rôle}
Racine logique du modèle (niveau 1 de l'arborescence). Contient
les listes de conteneurs et de palettes, ainsi que l'ensemble
des règles de compatibilité (\texttt{ReglesCompatibilite}).

\section{Contrôleurs}

\subsection{\texttt{ProduitControleur}}

\paragraph{Rôle}
Gère la collection de produits en mémoire et fournit des méthodes
de création utilisées par l'interface graphique.

\paragraph{Attribut interne}
\begin{itemize}
  \item \texttt{QVector<std::shared_ptr<Product>> m\_produits;}
\end{itemize}

\paragraph{Méthodes}
\begin{itemize}
  \item \texttt{std::shared\_ptr<Product> ajouterProduitAvecCaracteristiques(...);}
  \item \texttt{std::shared\_ptr<Product> ajouterProduitAvecCycleDeVie(...);}
  \item \texttt{void debugPrintProduits() const;}~: affichage dans la
        sortie de débogage Qt (liste des produits avec leurs propriétés).
\end{itemize}

Les méthodes d'ajout retournent un \texttt{shared\_ptr<Product>} afin
que le produit puisse être immédiatement ajouté dans un conteneur
via le \texttt{ConteneurControleur}.

\subsection{\texttt{ConteneurControleur}}

\paragraph{Rôle}
Gère la liste des conteneurs et permet d'y ajouter des produits.

\paragraph{Attribut interne}
\begin{itemize}
  \item \texttt{QVector<std::shared\_ptr<Conteneur>> m\_conteneurs;}
\end{itemize}

\paragraph{Méthodes}
\begin{itemize}
  \item \texttt{void ajouterConteneur(const QString\&, TypeConteneur, double);}
  \item \texttt{const QVector<std::shared\_ptr<Conteneur>>\& conteneurs() const;}
  \item \texttt{bool ajouterProduitAuConteneur(const QString\& idConteneur,
            const std::shared\_ptr<Product>\& produit);}
  \item \texttt{void debugPrintConteneurs() const;}
\end{itemize}

\paragraph{Principe}
Lorsqu'un produit est créé dans la boîte de dialogue
\texttt{ajouterProduit}, l'utilisateur peut choisir un conteneur
dans une \texttt{QComboBox}. Le contrôleur va alors retrouver
le conteneur via son identifiant et y ajouter le produit
(\texttt{Conteneur::ajouterProduit}).

\section{Interface Qt et intégration du modèle}

\subsection{\texttt{ajouterconteneur}}

\paragraph{Rôle}
Boîte de dialogue (\texttt{QDialog}) utilisée pour créer un nouveau
conteneur.

\paragraph{Éléments d'interface}
\begin{itemize}
  \item \texttt{IdConteneur\_2} : \texttt{QLineEdit} pour l'identifiant.
  \item \texttt{TypeConteneur\_2} : \texttt{QComboBox} alimentée par les
        valeurs de \texttt{TypeConteneur} via \texttt{QVariant}.
  \item \texttt{CapaciteMax\_2} : \texttt{QDoubleSpinBox}.
  \item Boutons \texttt{Créer} et \texttt{Annuler}.
\end{itemize}

\paragraph{Fonctionnement}
Lors du clic sur \og Créer \fg{}, la méthode
\texttt{on\_Creer\_clicked()} lit les valeurs des widgets et appelle
\texttt{ConteneurControleur::ajouterConteneur}. Le dialog renvoie
\texttt{QDialog::Accepted}.

\subsection{\texttt{ajouterProduit}}

\paragraph{Rôle}
Boîte de dialogue de création de produit. Elle gère deux types
de produits~: avec caractéristiques ou avec cycle de vie.

\paragraph{Éléments principaux}
\begin{itemize}
  \item Deux \texttt{QCheckBox} exclusives :
        \begin{itemize}
          \item \texttt{checkBox}~: \og Produit avec des caractéristiques \fg{}
          \item \texttt{checkBox\_2}~: \og Produit avec cycle de vie \fg{}
        \end{itemize}
  \item \texttt{TypeProduit\_2} : \texttt{QComboBox} alimentée par
        \texttt{TypeProduit}.
  \item \texttt{Etat\_2} : \texttt{QComboBox} alimentée par
        \texttt{EtatProduit}.
  \item Champs numériques : \texttt{CapaciteMax\_2}, \texttt{Poids\_2},
        \texttt{Volume\_2}.
  \item Dates : \texttt{DateEntree\_2}, \texttt{DatePeremption\_2}.
  \item \texttt{ConditionsConservation\_2} :
        \texttt{QPlainTextEdit} pour les conditions.
  \item \texttt{DansQuelConteneur\_2} : \texttt{QComboBox} listant tous les
        identifiants de conteneurs existants, obtenus auprès du
        \texttt{ConteneurControleur}.
\end{itemize}

\paragraph{Comportement dynamique}
\begin{itemize}
  \item Les deux cases à cocher sont mutuellement exclusives.
  \item Selon le type choisi :
        \begin{itemize}
          \item pour \textbf{Produit avec caractéristiques} :
                les champs \texttt{ConditionsConservation} sont visibles,
                \texttt{DatePeremption} est cachée.
          \item pour \textbf{Produit avec cycle de vie} :
                \texttt{DatePeremption} est visible,
                \texttt{ConditionsConservation} est cachée.
        \end{itemize}
  \item Lors du clic sur \og Créer \fg{} :
        \begin{itemize}
          \item le dialog appelle la méthode appropriée du
                \texttt{ProduitControleur} pour créer l'objet métier,
          \item si un conteneur est sélectionné dans
                \texttt{DansQuelConteneur\_2}, le produit est ajouté à ce
                conteneur via \texttt{ConteneurControleur::ajouterProduitAuConteneur}.
        \end{itemize}
\end{itemize}

\subsection{\texttt{MainWindow} et hiérarchie dans la \texttt{QTreeView}}

\paragraph{Rôle}
Fenêtre principale de l'application. Elle contient :
\begin{itemize}
  \item un \texttt{QComboBox} \texttt{comboBoxTypeModel} pour basculer
        entre les groupes \og Conteneur \fg{}, \og Palette \fg{} et
        \og Produit \fg{} ;
  \item un \texttt{QGroupBox} avec une \texttt{QTreeView} pour afficher
        l'arborescence \texttt{Conteneur} $\rightarrow$ \texttt{Produits}.
\end{itemize}

\paragraph{Modèle de la TreeView}
La \texttt{QTreeView} est alimentée par un \texttt{QStandardItemModel}
(\texttt{m\_treeModel}). La méthode \texttt{rebuildTreeView()} :

\begin{itemize}
  \item efface le modèle,
  \item parcourt la liste des conteneurs fournie par
        \texttt{ConteneurControleur::conteneurs()},
  \item pour chaque conteneur crée un item racine
        \og Conteneur \texttt{<Id>} \fg{},
  \item pour chaque produit du conteneur, crée un enfant
        \og Produit \texttt{<IdProduit>} \fg{}.
\end{itemize}

La méthode est appelée après chaque création de conteneur ou de produit,
afin de garder la vue toujours synchronisée avec le modèle.

\section*{Conclusion}

Le projet \emph{Warehouse Manager} implémente un modèle d'entrepôt
structuré, basé sur des classes métiers claires (\texttt{Product},
\texttt{Conteneur}, \texttt{Palette}, etc.), enrichi par des
contrôleurs qui font le lien avec l'interface Qt.  

Les dialogs d'ajout permettent de créer des objets cohérents
(en utilisant les énumérations du modèle) et de construire
progressivement une hiérarchie conteneurs / produits visualisable
dans la \texttt{QTreeView} de la fenêtre principale.

Ce document pourra être complété par la suite avec :
\begin{itemize}
  \item la description détaillée des algorithmes FIFO/FEFO de
        génération de palettes,
  \item la gestion et l'édition des règles de compatibilité
        (\texttt{ReglesCompatibilite}),
  \item des captures d'écran de l'interface finale.
\end{itemize}

\end{document}
